---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2024/9/15 0015 16:44
---

local coroutine = coroutine
local pairs = pairs
local table = table
local string = string
local tonumber = tonumber
local tostring = tostring
local ipairs = ipairs
local require = require
local package = package
local type = type
local pcall = pcall
local next = next
local os = os
local log_debug = log_debug
local log_error = log_error
local log_info = log_info

local g_pNode = g_pNode
local g_pManager = g_pNode:getManager()
local convert_ip2str = convert_ip2str
local md5sum = md5sum
local db_set = db_set
local db_get = db_get
local db_del = db_del
local db_batch = db_batch
--[[
bool db_set(const char* key, int64 key_length, const char* value, int64 value_length);
bool db_get(const char* key, int64 key_length, std::string& value);
bool db_del(const char* key, int64 key_length);
// bool db_batch
]]

local COMMAND_RPC_REQUEST = 1
local COMMAND_RPC_RESPONSE = 2

local COMMON_WAIT_TIMEOUT = 30000        -- 单位毫秒

--local function toHex(number)
--    if number == nil then
--        return number
--    end
--    return string.format("0x%x", number)
--end

local HTTP_HEADER_TEMPLATE = [[HTTP/1.1 %s
Access-Control-Allow-Origin: *%s
Content-Length: %d

%s]]
local HTTP_HEADER_SEPARATOR = [[

]]
local WelcomeHtml = [[<!DOCTYPE html>
<html>
<head>
<title>Welcome to rocket!</title>
<style>
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
</style>
</head>
<body>
<h1>Welcome to rocket!</h1>
<p>If you see this page, the rocket web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://space0x0.com/">space0x0.com</a>.<br/>
Commercial support is available at
<a href="http://space0x0.com/">space0x0.com</a>.</p>

<p><em>Thank you for using rocket.</em></p>
</body>
</html>]]

local JsonType = "application/json"
local EprotoType = "application/pb"
local MessagePackType = "application/mp"

--local http_error = require("http_error")
local rapidjson = require("rapidjson")
local eproto = require("eproto")

local rpc = class("rpc")

-- C++调用函数 Begin-------------------
function rpc:onTimerUpdate(callbackID, timerHandle)
    return rpc:doingTimeout(callbackID, timerHandle)
end
function rpc:onOpenConnect(handle, serverHandle, callbackID)
    log_debug("onOpenConnect", handle, serverHandle, callbackID)
    return  rpc:doingOpenConnect(handle, serverHandle, callbackID, true)
end
function rpc:onCloseConnect(handle, serverHandle, callbackID)
    log_debug("onCloseConnect", handle, serverHandle, callbackID)
    rpc:setHandleLevel(handle, nil)
    return  rpc:doingOpenConnect(handle, serverHandle, callbackID, false)
end
function rpc:onHandleBuffer(sourceServerIndex, buffer)
    local rpcReq = rpc:decodeRpcHead(buffer)
    local command = rpcReq.command
    rpcReq.sourceServerIndex = sourceServerIndex
    if command == COMMAND_RPC_REQUEST then
        log_debug("onHandleBuffer doingServerRequest", sourceServerIndex, command)
        return rpc:doingServerRequest(rpcReq.msg_id, rpcReq.body, rpcReq)
    elseif command == COMMAND_RPC_RESPONSE then
        log_debug("onHandleBuffer doingServerResponse", sourceServerIndex, command)
        return rpc:doingServerResponse(rpcReq.msg_id, rpcReq.body, rpcReq)
    else
        log_error("onHandleBuffer not handle command", command)
    end
end
function rpc:onReceiveWebSocket(handle, serverHandle, ip, buffer)
    local rpcReq = rpc:decodeRpcHead(buffer)
    local command = rpcReq.command
    rpcReq.handle = handle
    rpcReq.serverHandle = serverHandle
    rpcReq.ip = ip
    -- 设置当前可能绑定的uid
    local uid = rpcReq.uid or 0
    if uid == 0 then
        rpcReq.uid = serverHandle
    end
    if command == COMMAND_RPC_REQUEST then
        log_debug("onReceiveWebSocket doingSocketRequest", handle, ip, command)
        return rpc:doingSocketRequest(rpcReq.msg_id, rpcReq.body, rpcReq)
    elseif command == COMMAND_RPC_RESPONSE then
        log_debug("onReceiveWebSocket doingSocketResponse", handle, ip, command)
        return rpc:doingSocketResponse(rpcReq.msg_id, rpcReq.body, rpcReq)
    else
        log_error("onReceiveWebSocket not handle command", command)
    end
end
function rpc:onReceiveHttp(handle, serverHandle, ip, method, url, body, headers)
    log_debug("onReceiveHttp", handle, serverHandle, convert_ip2str(ip), method, url, body, headers)
    if method == "GET" then
        local rpcReq = {}
        rpcReq.handle = handle
        rpcReq.serverHandle = serverHandle
        rpcReq.ip = ip
        rpcReq.method = method
        rpcReq.url = url
        rpcReq.headers = headers
        local callback = function()
            local response = {}
            self.m_handler:onHttpGet(response, rpcReq)
            local headers_response = {}
            local responseBuffer = response.body
            if responseBuffer then
                headers_response["Content-Type"] = headers["Content-Type"]
            else
                responseBuffer = WelcomeHtml
                headers_response["Content-Type"] = "text/html"
            end
            rpc:responseHttpWithBody(responseBuffer, headers_response, rpcReq)
        end
        return rpc:execute(callback)
    end

    local contentType = headers["Content-Type"]
    local rpcReq
    if contentType == EprotoType then
        rpcReq = rpc:decodeRpcHead(body)
    elseif contentType == MessagePackType then
        rpcReq = eproto.unpack(body)
    else
        -- 默认使用JSON
        rpcReq = rapidjson.decode(body)
    end
    if not rpcReq then
        rpcReq = {}
        rpcReq.handle = handle
        rpc:responseHttpRequestError(rpcReq, 101, "data type not support contentType "..tostring(contentType))
        return
    end
    rpcReq.handle = handle
    rpcReq.serverHandle = serverHandle
    rpcReq.ip = ip
    rpcReq.method = method
    rpcReq.url = url
    rpcReq.headers = headers
    return rpc:doingHttpRequest(rpcReq.msg_id, rpcReq)
end
function rpc:onHttpResponse(handle, serverHandle, callbackID, statusCode, isRequestOK, body, headers)
    log_debug("onHttpResponse", handle, serverHandle, callbackID, statusCode, isRequestOK, body, headers)
    return rpc:doingHttpResponse(handle, serverHandle, callbackID, statusCode, isRequestOK, body, headers)
end
function rpc:onNextFrameActive()
    return rpc:doingNextFrameActive()
end
function rpc:onInitialize(pNode, moduleName)
    return rpc:initRpc(pNode, moduleName)
end
-- C++调用函数 End-------------------

-- ---------------------------------------------------
function rpc:initRpc(pNode, moduleName)
    self.m_moduleName = moduleName
    self.m_cbMap = {}
    self.m_coMap = {}
    self.m_loopTimerMap = {}
    self.m_loops = {}
    self.m_callbacks = {}
    self.m_msgMap = {}          -- msgID -> info
    self.m_id = 10000
    self.m_loopTimerID = 0
    self.m_handleLevel = {}
    log_debug("initRpc moduleName", moduleName)
    rpc:runCoroutine(function()
        return rpc:delayInit()
    end)
end
function rpc:hotUpdate(request, response, rpcReq)
    log_debug("hotUpdate called", self.m_moduleName, request)
    local config = require("config")
    --if rpcReq.msg ~= config.hotUpdateKey then
    --    log_error("hotUpdate key error", rpcReq.msg)
    --    return
    --end
    package.loaded["script.init"] = nil
    require("script.init")

    local require_path = config.base_require_path
    -- 热更新加载模块
    for _,p in ipairs(require_path) do
        p = "script."..p..".init"
        log_info("hotUpdate", p)
        pcall(require, p)
    end
    require_path = config.requirePath or {}
    for _,p in ipairs(require_path) do
        p = "script."..p..".init"
        log_info("hotUpdate", p)
        pcall(require, p)
    end

    rpc:registerMainProto("proto", true, nil)

    -- handler 文件更新
    local handlerFile = config.handlerFile
    package.loaded[handlerFile] = nil
    pcall(require, handlerFile)

    -- handler内部热更新
    local m_handler = self.m_handler
    if m_handler then
        m_handler:onHotUpdate()
    end

    self:processCollectGarbage()
    response.result = true
    response.moduleName = self.m_moduleName
end
function rpc:hotUpdateReceive(request, response, rpcReq)
    log_debug("hotUpdateReceive called", self.m_moduleName, request)
    local config = require("config")
    if rpcReq.msg ~= config.hotUpdateKey then
        log_error("hotUpdateReceive key error", rpcReq.msg)
        return
    end
    rpc:broadcast(1001, request)
end
function rpc:delayInit()
    log_debug("delayInit called")
    -- rpc 监听热更新命令和接口
    rpc:register(1000, rpc, "hotUpdateReceive")
    rpc:register(1001, rpc, "hotUpdate")

    -- 设置当前的handler
    local config = require("config")
    local handlerFile = config.handlerFile
    log_debug("delayInit require handlerFile", handlerFile)
    local result,handlerClass = pcall(require, handlerFile)
    if not result then
        log_error("load handlerClass failed", handlerFile, handlerClass)
    end
    log_debug("delayInit new handlerClass", handlerFile)
    local handlerObject = handlerClass.new()
    rpc:setHandler(handlerObject)
    log_debug("delayInit handlerObject onInitialize", handlerFile)
    handlerObject:onInitialize()

    rpc:registerMainProto("proto", true, nil)

    log_debug("delayInit handlerObject onHotUpdate", handlerFile)
    handlerObject:onHotUpdate()
    handlerObject:onInitializeEnd()
end
-- 设置处理对象
function rpc:setHandler(handlerObject)
    self.m_handler = handlerObject
end
-- ---------------------------------------------------
-- 协程相关接口
-- 给某个线程发送信息
function rpc:send(serverIndex, msgID, uid, request, response)
    local msgInfo = self.m_msgMap[msgID]
    if msgInfo == nil then
        log_error("rpc:send msgID not handle", msgID)
        return -1
    end
    local callbackID = 0
    if response ~= nil then
        local result
        result,callbackID = rpc:getCoroutineCallbackID()
    end
    local body
    if type(request) == "string" then
        body = request
    else
        body = rpc:encodeRequestByInfo(msgInfo, request)
        if not body then
            log_error("rpc:send encodeRequest failed", msgID, request)
            return -2
        end
    end
    local headReq = {
        msg_id = msgID;
        body = body;
        callback_id = callbackID;
        uid = uid;
        command = COMMAND_RPC_REQUEST;
    }
    local buffer = rpc:encodeRpcHead(body, headReq)
    local result = g_pNode:send(buffer, #buffer, serverIndex)
    if not result then
        log_error("rpc:send failed", serverIndex)
        return -3
    end
    local error_code = 0
    local rpcReq
    if response ~= nil then
        local isOK,responseValue
        isOK,responseValue,rpcReq = coroutine.yield(COMMON_WAIT_TIMEOUT)
        if not isOK then
            log_error("rpc:send for timeout", serverIndex, msgID, callbackID, responseValue)
            return -4
        end
        for k,v in pairs(responseValue) do
            response[k] = v
        end
        error_code = rpcReq.errorCode or 0
    end
    return error_code,rpcReq
end
-- 给所有子线程广播信息，自己也会收到消息
function rpc:broadcast(msgID, request)
    local msgInfo = self.m_msgMap[msgID]
    if msgInfo == nil then
        log_error("rpc:broadcast msgID not handle", msgID)
        return false
    end
    local body = rpc:encodeRequestByInfo(msgInfo, request)
    if not body then
        log_error("rpc:broadcast encodeRequestByInfo failed", msgID, request)
        return false
    end
    local rpcReq = {
        msg_id = msgID;
        callback_id = 0;
        uid = 0;
    }
    local buffer = rpc:encodeRpcHead(COMMAND_RPC_REQUEST, body, rpcReq)
    g_pNode:broadcast(buffer, #buffer)
    return true
end
-- 发起Http请求
function rpc:http(method, url, headers, body, response, timeout, handle, isKeepAlive)
    method = method:upper()		-- C++ 只认大写
    handle = handle or 0
    timeout = timeout or COMMON_WAIT_TIMEOUT
    local callbackID = 0
    if response ~= nil then
        local result
        result,callbackID = rpc:getCoroutineCallbackID()
        if not result then
            return -9
        end
    end
    --if method == "POST" and headers["Content-Length"] == nil and headers["content-length"] == nil then
    --    headers["Content-Length"] = #body
    --end
    local pRequestData = g_pManager:getRequestData()
    pRequestData:initialize(method, url, body, #body, callbackID)
    for k,v in pairs(headers) do
        pRequestData:appendHeader(k, v)
    end
    if isKeepAlive then
        pRequestData:setKeepAlive(true)
    end
    handle = g_pManager:sendHttpRequest(handle, pRequestData)
    if handle == 0 then
        log_error("request for sendCurlRequest failed", handle, method, url, headers, callbackID)
        return -8
    end
    --    log_debug("http request with handle", handle)
    if response ~= nil then
        local isOK,responseValue = coroutine.yield(timeout)
        if not isOK then
            log_error("request for timeout", method, url, headers, callbackID)
            return -4
        end
        for k,v in pairs(responseValue) do
            response[k] = v
        end
    end
    return 0,handle
end
-- 打开连接
function rpc:openWebSocket(url, serverHandle, phonyIP)
    local callbackID = 0
    local coInfo
    local co = coroutine.running()
    if co ~= nil then
        coInfo = rpc:getInfoByCO(co)
        if coInfo then
            callbackID = coInfo.callbackID
        else
            log_error("rpc:openWebSocket but no co info found", url, serverHandle, phonyIP)
        end
    else
        log_error("rpc:openWebSocket but no running co found", url, serverHandle, phonyIP)
    end
    local handle = g_pManager:openWebSocket(url, callbackID, serverHandle, phonyIP);
    if handle == 0 then
        return handle
    end
    if coInfo then
        coInfo.connectHandle = handle
    end
    local isOK = coroutine.yield(5000)
    if not isOK then
        return 0
    end
    return handle
end
-- 设置一个计时器，单位毫秒
function rpc:schedule(callback, timeoutOrCallback, loop, fromTime)
    local timeout = timeoutOrCallback
    if type(timeout) == "number" then
        timeout = function()
            return timeoutOrCallback
        end
    end
    if loop then
        local coCallback = function(coInfo)
            -- 第一次挂起
            coInfo.isLoop = true
            local timeCount = timeout()
            coInfo.timeCount = timeCount
            rpc:scheduleTimeout(coInfo, timeCount, fromTime)
            -- 循环定时器，当前协程函数将会循环执行
            while coInfo.isLoop do
                coInfo.timeCount = timeCount
                coroutine.yield(timeCount)
                --log_debug("rpc:schedule isLoop=true", timeCount)
                -- 计时器调用函数放到新协程中处理
                rpc:runCoroutine(callback)
                timeCount = timeout()
            end
        end
        return rpc:execute(coCallback)
    else
        local coCallback = function(coInfo)
            -- 第一次挂起
            coInfo.isLoop = false
            local timeCount = timeout()
            coInfo.timeCount = timeCount
            rpc:scheduleTimeout(coInfo, timeCount, fromTime)
            coroutine.yield(timeCount)
            -- 非循环定时器，只执行一次
            callback(coInfo)
        end
        return rpc:execute(coCallback)
    end
end
-- 当前线程挂起，一定时间之后重新调用
function rpc:waitTimeout(timeout)
    local fromTime = 0
    local coInfo = rpc:getCurrentCoroutineInfo()
    rpc:scheduleTimeout(coInfo, timeout, fromTime)
    coroutine.yield(timeout)
end
-- 执行一个协程函数
function rpc:execute(callback)
    -- 创建协程
    local co = coroutine.create(callback)
    -- 注册当前的协程
    local callbackID,coInfo = rpc:registerCoroutine(co)
    if not rpc:resumeCoroutine(callbackID, coInfo, coInfo) then
        log_error("rpc:execute checkCoroutine failed")
        return false
    end
    return true,callbackID,coInfo
end
-- 设置循环定时器
function rpc:scheduleLoopTimer(callback, timeoutOrCallback, fromTime)
    fromTime = fromTime or 0
    local timeout = timeoutOrCallback
    if type(timeout) == "number" then
        timeout = function()
            return timeoutOrCallback
        end
    end
    local callbackID = self:nextLoopTimerID()
    local timeCount = timeout()
    local timerHandle = g_pNode:startTimer(callbackID, timeCount, fromTime)
    self.m_loopTimerMap[callbackID] = {
        callbackID = callbackID;
        timerHandle = timerHandle;
        callback = callback;
        timeout = timeout;
    }
    return callbackID
end
function rpc:stopLoopTimer(callbackID)
    local info = self.m_loopTimerMap[callbackID]
    if info then
        self.m_loopTimerMap[callbackID] = nil
        g_pNode:removeTimer(info.timerHandle)
    end
end
function rpc:executeLoopTimer(callbackID)
    local info = self.m_loopTimerMap[callbackID]
    if info then
        --log_debug("executeLoopTimer", callbackID)
        rpc:runCoroutine(info.callback)
        local timeCount = info.timeout()
        return timeCount
    end
end
function rpc:getCoroutineCallbackID()
    local callbackID = 0
    local co = coroutine.running()
    if co == nil then
        log_error("getCoroutineCallbackID should have a coroutine running")
        return false,callbackID
    end
    local coInfo = rpc:getInfoByCO(co)
    if coInfo == nil then
        log_error("getCoroutineCallbackID can not find coroutine info")
        return false,callbackID
    end
    callbackID = coInfo.callbackID
    return true,callbackID
end
function rpc:getCurrentCoroutineInfo()
    local co = coroutine.running()
    if co ~= nil then
        local coInfo = rpc:getInfoByCO(co)
        if coInfo then
            return coInfo
        else
            log_error("rpc:getCurrentCoroutineInfo but no co info found")
        end
    else
        log_error("rpc:getCurrentCoroutineInfo but no running co found")
    end
end
-- 当前协程结束之后，直接调用callback，无协程环境
function rpc:runCallback(callback)
    table.insert(self.m_callbacks, callback)
    g_pNode:setNextFrameActive()
end
-- 当前协程结束之后，另起新协程处理callback
function rpc:runCoroutine(callback)
    table.insert(self.m_loops, callback)
    g_pNode:setNextFrameActive()
end
function rpc:runMultiCoroutine(callbackArray, timeout)
    local totalCount = #callbackArray
    if totalCount == 0 then
        return true
    end
    local result,callbackID = rpc:getCoroutineCallbackID()
    if callbackID == 0 then
        return false
    end
    local finishedCount = 0
    local okCount = 0
    for _,cb in ipairs(callbackArray) do
        local function callback()
            if cb() then
                okCount = okCount + 1
            end
            finishedCount = finishedCount + 1
            if callbackID > 0 and finishedCount >= totalCount then
                local result = (okCount == totalCount)
                self:responseCoroutineByResult(callbackID, result)
            end
        end
        rpc:runCoroutine(callback)
    end
    timeout = timeout or COMMON_WAIT_TIMEOUT
    --    log_debug("rpcRunMultiCoroutine timeout", timeout, "callbackID", callbackID)
    local isOK,result = coroutine.yield(timeout)
    --    log_debug("rpcRunMultiCoroutine end", isOK, "callbackID", callbackID, "result", result)
    return isOK and result
end
function rpc:responseCoroutineByResult(callbackID, result)
    local coInfo = rpc:getInfoByID(callbackID)
    if coInfo == nil then
        log_error("responseCoroutineByResult can not find coInfo", callbackID)
        return
    end
    -- 执行协程函数
    if not rpc:resumeCoroutine(callbackID, coInfo, true, result) then
        log_error("responseCoroutineByResult checkCoroutine failed")
    end
end
function rpc:registerCoroutine(co)
    local callbackID = rpc:nextID()
    local coInfo = { callbackID=callbackID, co=co }
    self.m_cbMap[callbackID] = coInfo
    self.m_coMap[co] = coInfo
    return callbackID,coInfo
end
function rpc:changeCoroutineCallbackID(coInfo)
    -- 注释掉老的callbackID
    local callbackID = coInfo.callbackID
    self.m_cbMap[callbackID] = nil
    -- 生成新的callbackID
    local newCallbackID = rpc:nextID()
    coInfo.callbackID = newCallbackID
    self.m_cbMap[newCallbackID] = coInfo
    --	log_debug("changeCoroutineCallbackID old", callbackID, "new", newCallbackID)
    return newCallbackID,coInfo
end
function rpc:getInfoByID(callbackID)
    return self.m_cbMap[callbackID]
end
function rpc:getInfoByCO(co)
    return self.m_coMap[co]
end
function rpc:getTimerLeft(coInfo)
    local timerHandle = coInfo.timerHandle
    if timerHandle ~= nil then
        return g_pNode:getTimerLeft(timerHandle)
    end
    return 0
end
function rpc:remove(coInfo)
    return rpc:removeByID(coInfo.callbackID)
end
function rpc:removeByID(callbackID)
    --log_debug("rpc:removeByID", callbackID)
    local coInfo = self.m_cbMap[callbackID]
    if coInfo ~= nil then
        coInfo.isLoop = nil
        self.m_cbMap[callbackID] = nil
        self.m_coMap[coInfo.co] = nil
        local timerHandle = coInfo.timerHandle
        --		log_debug("rpc:removeByID", timerHandle, callbackID)
        if timerHandle then
            --			log_debug("rpc:removeByID removeTimer", timerHandle, callbackID)
            g_pNode:removeTimer(timerHandle)
        end
    else
        log_error("rpc:removeByID not found coInfo", callbackID)
    end
end
function rpc:nextLoopTimerID()
    local id = self.m_loopTimerID
    local m_loopTimerMap = self.m_loopTimerMap
    while true do
        id = id + 1
        if id > 10000 then
            id = 1
        end
        if m_loopTimerMap[id] == nil then
            self.m_loopTimerID = id
            return id
        end
        log_debug("nextLoopTimerID find next", id)
    end
end
function rpc:nextID()
    local id = self.m_id
    local m_cbMap = self.m_cbMap
    while true do
        id = id + 1
        if id > 2147483647 then
            id = 10001
        end
        if m_cbMap[id] == nil then
            self.m_id = id
            return id
        end
        log_debug("nextID find next", id)
    end
end
function rpc:scheduleTimeout(coInfo, timeout, fromTime)
    fromTime = fromTime or 0
    local timerHandle = coInfo.timerHandle
    local callbackID = coInfo.callbackID
    if timerHandle ~= nil then
        --        log_debug("changeTimerCallbackID timerHandle", timerHandle, callbackID, timeout)
        if coInfo.isLoop then
            -- coInfo.timeCount是上一次间隔时间；timeout是当前最新间隔时间
            if timeout ~= coInfo.timeCount then
                coInfo.timeCount = timeout
                g_pNode:changeTimer(timerHandle, callbackID, timeout, fromTime)
            else
                --g_pNode:changeTimer(timerHandle, callbackID, timeout, fromTime)
                g_pNode:changeTimerCallbackID(timerHandle, callbackID)
            end
        else
            g_pNode:changeTimer(timerHandle, callbackID, timeout, fromTime)
        end
    else
        --log_debug("scheduleTimeout startTimer", callbackID, timeout)
        timerHandle = g_pNode:startTimer(callbackID, timeout, fromTime)
        coInfo.timerHandle = timerHandle
        --        log_debug("startTimer timerHandle", timerHandle, callbackID, timeout)
    end
end
-- ---------------------------------------------------
function rpc:processCollectGarbage()
    -- 获取当前使用的内存(KB)
    local memoryUsed = collectgarbage("count")
    log_debug("memory used before:", memoryUsed)

    -- 立即触发一次垃圾收集
    collectgarbage("collect")

    -- 获取当前使用的内存(KB)
    memoryUsed = collectgarbage("count")
    log_debug("memory used after:", memoryUsed)
end
-- 处理回传的数据
function rpc:doingTimeout(callbackID, timerHandle)
    local timeCount = self:executeLoopTimer(callbackID)
    if timeCount then
        return timeCount
    end

    --    log_debug("rpc:doingTimeout with callbackID", callbackID)
    local coInfo = rpc:getInfoByID(callbackID)
    if coInfo == nil then
        log_error("rpc:doingTimeout can not find coInfo", callbackID, timerHandle)
        return -1
    end
    if not rpc:resumeCoroutine(callbackID, coInfo, false) then
        log_error("rpc:doingTimeout checkCoroutine failed", callbackID, timerHandle)
        return -1
    end
    if coInfo.isLoop then
        return coInfo.timeCount
    end
    return -1
end
function rpc:doingNextFrameActive()
    --    log_debug("rpc:doingNextFrameActive")
    local m_loops = self.m_loops
    if #m_loops > 0 then
        self.m_loops = {}
        for _,cb in ipairs(m_loops) do
            local res,err = pcall(function()
                rpc:execute(cb)
            end)
            if not res then
                log_error("rpc m_loops failed", err)
            end
        end
    end
    local m_callbacks = self.m_callbacks
    if #m_callbacks > 0 then
        self.m_callbacks = {}
        for _,cb in ipairs(m_callbacks) do
            local res,err = pcall(cb)
            if not res then
                log_error("rpc m_callbacks failed", err)
            end
        end
    end
end
function rpc:resumeCoroutine(callbackID, coInfo, ...)
    local co = coInfo.co
    -- 执行协程函数
    local result,returnValue = coroutine.resume(co, ...)
    if not result then
        local traceMsg = debug.traceback()
        log_error("rpc:checkCoroutine failed", returnValue, traceMsg)
        rpc:removeByID(callbackID)
        return false
    end
    -- 当前的请求被挂起了，需要处理挂起操作
    local co_status = coroutine.status(co)
    --	log_debug("rpc:resumeCoroutine co_status", co_status, type(co_status), callbackID)
    if co_status == "suspended" then
        -- 设定超时移除的计时器 returnValue 为 timeout
        rpc:scheduleTimeout(coInfo, returnValue)
    else
        -- 执行结束，直接移除当前注册的协程
        rpc:removeByID(callbackID)
    end
    return true
end
function rpc:responseCoroutine(response, rpcReq)
    local callbackID = rpcReq.callback_id or 0
    --	log_debug("rpc:responseCoroutine with callbackID", callbackID, rpcReq.msg_id)
    local coInfo = rpc:getInfoByID(callbackID)
    if coInfo == nil then
        log_error("rpc:responseCoroutine can not find coInfo", callbackID)
        return
    end
    if not rpc:resumeCoroutine(callbackID, coInfo, true, response, rpcReq) then
        log_error("rpc:responseCoroutine checkCoroutine failed")
        return
    end
end
function rpc:doingOpenConnect(handle, serverHandle, callbackID, result)
    log_debug("rpc:doingOpenConnect with callbackID", callbackID, "serverHandle", serverHandle, result)
    if callbackID == 0 then
        return
    end
    local coInfo = rpc:getInfoByID(callbackID)
    if coInfo == nil then
        --        log_error("handler:doingOpenConnect can not find coInfo", callbackID)

        return
    end
    if coInfo.connectHandle == handle then
        -- 执行协程函数
        coInfo.connectHandle = nil
        if not rpc:resumeCoroutine(callbackID, coInfo, result) then
            log_error("rpc:doingOpenConnect checkCoroutine failed")
        end
        --    else
        --        log_error("doingOpenConnect coInfo not found", handle, callbackID, result)
        return true
    end
end
function rpc:doingServerRequest(msgID, body, rpcReq)
    -- 当前服务处理该消息
    local msgInfo = self.m_msgMap[msgID]
    if msgInfo == nil then
        log_error("rpc:doingServerRequest not register", msgID)
        return
    end
    local info,obj,objFunc = rpc:findMsgInfo(msgID)
    if info == nil then
        log_error("rpc:doingServerRequest not handle msgID", msgID)
        return
    end
    local callback = function()
        local uid = rpcReq.uid or 0
        local response = {}
        local request = rpc:decodeRpc(false, msgID, body, info)
        log_debug("rpc:doingServerRequest call obj function begin", msgID, "uid", uid)
        objFunc(obj, request, response, rpcReq)
        local errorCode = rpcReq.error_code or 0
        log_debug("rpc:doingServerRequest call obj function end", msgID, "uid", uid, "errorCode", errorCode)
        local callbackID = rpcReq.callback_id or 0
        if callbackID > 0 then
            local responseBody = rpc:encodeResponseByInfo(info, response)
            if not responseBody then
                log_error("rpc:doingServerRequest encodeResponseByInfo failed", msgID, response)
                return
            end
            local buffer = rpc:encodeRpcHead(COMMAND_RPC_RESPONSE, responseBody, rpcReq)
            g_pNode:send(buffer, #buffer, rpcReq.sourceServerIndex)
            log_debug("rpc:doingServerRequest response sendData", msgID)
        end
    end
    if not rpc:execute(callback) then
        log_error("rpc:doingServerRequest execute error", msgID)
        return
    end
end
function rpc:doingServerResponse(msgID, body, rpcReq)
    local callbackID = rpcReq.callback_id or 0
    --	log_debug("rpc:doingServerResponse with callbackID", callbackID, rpcReq.msg_id)
    local coInfo = rpc:getInfoByID(callbackID)
    if coInfo == nil then
        log_error("rpc:doingServerResponse can not find coInfo", callbackID)
        return
    end
    local info = self.m_msgMap[msgID]
    if info == nil then
        log_error("rpc:doingServerResponse not handle", msgID)
        return
    end
    local response = rpc:decodeRpc(true, msgID, body, info)
    return rpc:responseCoroutine(response, rpcReq)
end
function rpc:doingSocketRequest(msgID, body, rpcReq)
    -- 当前服务处理该消息
    local msgInfo = self.m_msgMap[msgID]
    if msgInfo == nil then
        log_error("rpc:doingSocketRequest not register", msgID)
        return
    end
    -- 校验当前的请求，是否在它当前的级别以下
    local handleLevel = rpc:getHandleLevel(rpcReq.handle)
    local msgLevel = msgInfo.msgLevel or 0
    if handleLevel < msgLevel then
        log_error("rpc:doingSocketRequest not handle msgLevel not match", msgID, "handleLevel", handleLevel, "msgLevel", msgLevel)
        return
    end

    local info,obj,objFunc = rpc:findMsgInfo(msgID)
    if info == nil then
        log_error("rpc:doingSocketRequest not handle msgID", msgID)
        return
    end
    local callback = function()
        local uid = rpcReq.uid or 0
        local response = {}
        local request = rpc:decodeRpc(false, msgID, body, info)
        log_debug("rpc:doingSocketRequest call obj function begin", msgID, "uid", uid)
        objFunc(obj, request, response, rpcReq)
        local errorCode = rpcReq.error_code or 0
        log_debug("rpc:doingSocketRequest call obj function end", msgID, "uid", uid, "errorCode", errorCode)
        local callbackID = rpcReq.callback_id or 0
        if callbackID > 0 then
            local responseBody = rpc:encodeResponseByInfo(info, response)
            if not responseBody then
                log_error("rpc:doingSocketRequest encodeResponseByInfo failed", msgID, response)
                return
            end
            local buffer = rpc:encodeRpcHead(COMMAND_RPC_RESPONSE, responseBody, rpcReq)
            local result = g_pManager:sendWebSocket(rpcReq.handle, buffer, #buffer)
            log_debug("rpc:doingSocketRequest response sendData", result, msgID)
        end
    end
    if not rpc:execute(callback) then
        log_error("rpc:doingSocketRequest execute error", msgID)
        return
    end
end
function rpc:doingSocketResponse(msgID, body, rpcReq)
    local callbackID = rpcReq.callback_id or 0
    --	log_debug("rpc:doingSocketResponse with callbackID", callbackID, rpcReq.msg_id)
    local coInfo = rpc:getInfoByID(callbackID)
    if coInfo == nil then
        log_error("rpc:doingSocketResponse can not find coInfo", callbackID)
        return
    end
    local info = self.m_msgMap[msgID]
    if info == nil then
        log_error("rpc:doingSocketResponse not handle", msgID)
        return
    end
    local response = rpc:decodeRpc(true, msgID, body, info)
    return rpc:responseCoroutine(response, rpcReq)
end
function rpc:doingHttpRequest(msgID, rpcReq)
    local msgInfo = self.m_msgMap[msgID]
    if msgInfo == nil then
        --log_error("rpc:doingHttpRequest not register", msgID)
        rpc:responseHttpRequestError(rpcReq, 102, "not register msgID "..tostring(msgID))
        return
    end
    -- 校验当前msg携带的信息是否已经经过验证
    local msgLevel = msgInfo.msgLevel or 0
    if msgLevel > 0 then
        local msg = rpcReq.msg
        if not msg then
            rpc:responseHttpRequestError(rpcReq, 103, "msg is empty "..tostring(msg))
            return
        end
        local handleLevel = rpc:getSessionLevel(msg)
        if not handleLevel then
            rpc:responseHttpRequestError(rpcReq, 104, "msg is not valid "..tostring(msg))
            return
        end
        if handleLevel < msgLevel then
            log_error("rpc:doingHttpRequest not handle msgLevel not match", msgID, "handleLevel", handleLevel, "msgLevel", msgLevel)
            rpc:responseHttpRequestError(rpcReq, 105, "msg level not match "..tostring(msg))
            return
        end
    end
    -- 当前服务处理该消息
    local info,obj,objFunc = rpc:findMsgInfo(msgID)
    if info == nil then
        log_error("rpc:doingHttpRequest not handle msgID", msgID)
        rpc:responseHttpRequestError(rpcReq, 106, "not handle msgID "..tostring(msgID))
        return
    end
    local callback = function()
        local body = rpcReq.body
        local response = {}
        local request = rpc:decodeRpc(false, msgID, body, info)
        log_debug("rpc:doingHttpRequest call obj function begin", msgID, request)
        objFunc(obj, request, response, rpcReq)
        local responseBody = rpc:encodeResponseByInfo(info, response)
        if not responseBody then
            log_error("rpc:doingHttpRequest encodeResponseByInfo failed", msgID, response)
            rpc:responseHttpRequestError(rpcReq, 107, "encodeResponseByInfo failed")
            return
        end
        local contentType = rpcReq.headers["Content-Type"]
        local responseBuffer = rpc:encodeRpcHeadByContentType(contentType, COMMAND_RPC_RESPONSE, responseBody, rpcReq)
        local headers_response = {}
        headers_response["Content-Type"] = rpcReq.headers["Content-Type"]
        rpc:responseHttpWithBody(responseBuffer, headers_response, rpcReq)
    end
    if not rpc:execute(callback) then
        log_error("rpc:doingHttpRequest execute error", msgID)
        return
    end
end
function rpc:responseHttpWithBody(responseBuffer, headers, rpcReq)
    headers = headers or {}
    local handle = rpcReq.handle
    local response_code = "200 OK"
    -- HTTP请求成功回应码
    --if headers["Content-Type"] == nil then
    --    headers["Content-Type"] = rpcReq.headers["Content-Type"] or JsonType
    --end
    local headersData
    if next(headers) ~= nil then
        local headers_arr = {}
        for k,v in pairs(headers) do
            table.insert(headers_arr, k..": "..v)
        end
        headersData = table.concat(headers_arr, HTTP_HEADER_SEPARATOR)
        headersData = HTTP_HEADER_SEPARATOR .. headersData
    else
        headersData = ""
    end
    local buffer = string.format(HTTP_HEADER_TEMPLATE, response_code, headersData, #responseBuffer, responseBuffer)
    local result = g_pManager:responseHttp(handle, buffer, #buffer)
    if not result then
        log_error("rpc:responseHttpWithBody for response failed", rpcReq.url, handle, "msg_id", rpcReq.msg_id, "uid", rpcReq.uid, buffer)
    else
        log_debug("rpc:responseHttpWithBody for response OK", rpcReq.url, handle, "msg_id", rpcReq.msg_id, "uid", rpcReq.uid)
    end
end
function rpc:doingHttpResponse(handle, serverHandle, callbackID, statusCode, isRequestOK, body, headers)
    log_debug("rpc:doingHttpResponse with handle", handle, statusCode, isRequestOK, "serverHandle", serverHandle, "callbackID", callbackID)
    local coInfo = rpc:getInfoByID(callbackID)
    if coInfo == nil then
        log_error("rpc:doingHttpResponse can not find coInfo", callbackID)
        return
    end
    -- 执行协程函数
    local response = {
        statusCode = statusCode;
        isOK = isRequestOK;
        body = body;
        headers = headers;
        handle = handle;
        serverHandle = serverHandle;
    }
    if not rpc:resumeCoroutine(callbackID, coInfo, true, response) then
        log_error("rpc:doingHttpResponse checkCoroutine failed")
        return
    end
end
function rpc:responseHttpRequestError(rpcReq, error_code, errMsg)
    local handle = rpcReq.handle
    error_code = error_code or rpcReq.error_code or 0
    local msg = rpcReq.msg or errMsg
    local body = rapidjson.encode({error_code=error_code, msg=msg})
    local bodyLength = #body
    -- HTTP请求成功回应码
    local buffer = string.format(HTTP_HEADER_TEMPLATE, "200 OK", HTTP_HEADER_SEPARATOR.."Content-Type: application/json", bodyLength, body)
    local result = g_pManager:responseHttp(handle, buffer, #buffer)
    log_debug("responseHttpRequestError", result, error_code, errMsg)
end
-- ---------------------------------------------------
-- http 请求登录成功之后，设定当前session的连接等级
function rpc:setSessionLevel(session, level)
    --local value = tonumber(level)
    local data = {
        level = level;
        create_time = os.time();
    }
    local value = rapidjson.encode(data)
    local result = db_set(session, value)
    return result
end
function rpc:getSessionLevel(session)
    local result,value = db_get(session)
    if not result then
        return
    end
    local data = rapidjson.decode(value)
    --local handleLevel = tonumber(value)
    local handleLevel = data.level
    return handleLevel
end
-- websocket 经过验证之后，设定当前的连接等级
function rpc:setHandleLevel(handle, level)
    self.m_handleLevel[handle] = level
end
function rpc:getHandleLevel(handle)
    return self.m_handleLevel[handle] or 0
end
function rpc:reloadProtoFile(file, protoState, bPrintEror, loadedPBFileMap)
    package.loaded[file] = nil
    local result,proto = pcall(require, file)
    if not result then
        if bPrintEror then
            log_error("reloadProtoFile require failed", file, proto)
        else
            log_info("reloadProtoFile require failed", file)
        end
        return
    end
    loadedPBFileMap = loadedPBFileMap or {}
    --    local proto = require(file)
    for _,name in pairs(proto.files) do
        if not loadedPBFileMap[name] then
            loadedPBFileMap[name] = file
            local file_name = "script.pb."..name
            package.loaded[file_name] = nil
            local data = require(file_name)
            local buf = eproto.pack(data)
            local result = eproto.register(buf, protoState)
            log_info("eproto register", name, "result", result, "data", data)
        end
    end
    return proto
end
function rpc:registerMainProto(file, bPrintEror, loadedPBFileMap)
    local m_handler = self.m_handler
    local proto = rpc:reloadProtoFile(file, nil, bPrintEror, loadedPBFileMap)
    if proto then
        for _,info in ipairs(proto.messages) do
            local msgLevel = info[1]
            local msgID = info[2]
            local msgSource = info[3]
            local requestName = info[4]
            local responseName = info[5]
            local objFuncName = info[6]
            rpc:registerProto(msgLevel, msgID, msgSource, requestName, responseName)
            if objFuncName then
                rpc:register(msgID, m_handler, objFuncName)
            end
        end
    end
end
-- objFuncName执行方法， endFunc处理调用结束之后的逻辑
function rpc:register(msgID, obj, objFuncName)
    local msgInfo = self.m_msgMap[msgID]
    if msgInfo == nil then
        --        log_error("rpc:register failed msgInfo == nil", msgID)
        --        return
        msgInfo = {}
        self.m_msgMap[msgID] = msgInfo
    end
    log_info("register function", msgID, objFuncName)
    local objFunc = obj[objFuncName]
    if objFunc == nil then
        log_error("register function is nil", msgID, objFuncName)
    end
    msgInfo.obj = obj
    msgInfo.objFuncName = objFuncName
    msgInfo.objFunc = objFunc
end
-- 注册基础信息，用于encode，decode，路由
function rpc:registerProto(msgLevel, msgID, msgSource, requestName, responseName)
    local m_msgMap = self.m_msgMap
    local msgInfo = m_msgMap[msgID]
    log_info("rpc proto", msgLevel, msgID, msgSource, requestName, responseName)
    if msgInfo == nil then
        msgInfo = { msgLevel=msgLevel, msgID=msgID, msgSource=msgSource, requestName=requestName, responseName=responseName }
        m_msgMap[msgID] = msgInfo
    else
        msgInfo.msgLevel = msgLevel
        msgInfo.msgID = msgID
        msgInfo.msgSource = msgSource
        msgInfo.requestName = requestName
        msgInfo.responseName = responseName
    end
end
-- 取消组件消息的注册
function rpc:unregister(logicObj)
    for _,msgInfo in pairs(self.m_msgMap) do
        local obj = msgInfo.obj
        if obj then
            if obj == logicObj or obj == logicObj:getDelegate() then
                msgInfo.obj = nil
                msgInfo.objFuncName = nil
            end
        end
    end
end
function rpc:getProto(msgID)
    return self.m_msgMap[msgID]
end
function rpc:findMsgInfo(msgID)
    local info = self.m_msgMap[msgID]
    if info == nil then
        log_debug("msg is not registered", msgID)
        return
    end
    local obj = info.obj
    if obj == nil then
        log_debug("msg is not registered for handle", msgID)
        return
    end
    --local objFunc = obj[info.objFuncName]
    local objFunc = info.objFunc
    if objFunc == nil then
        log_debug("rpc:findMsgInfo for objFunc == nil", msgID)
        return
    end
    return info,obj,objFunc
end
function rpc:isHandleMessage(msgID)
    local msgInfo = self.m_msgMap[msgID]
    if msgInfo == nil then
        return false
    end
    return ( msgInfo.objFuncName ~= nil )
end
function rpc:encodeRequest(msgID, request)
    local info = self.m_msgMap[msgID]
    if info == nil then
        log_error("encodeRequest failed info == nil", msgID)
        return
    end
    return rpc:encodeRequestByInfo(info, request)
end
function rpc:encodeRequestByInfo(info, request)
    local msgSource = info.msgSource
    if msgSource == "pb" then
        -- log_debug("requestName:", info.requestName, ", request:", request)
        local buffer,err = eproto.encode(info.requestName, request)
        if not buffer then
            log_error("encodeRequest failed eproto.encode", messageIndex, "code", err, info.requestName, request)
            return
        end
        return buffer
    elseif msgSource == "mp" then
        local buffer = eproto.pack(request)
        return buffer
    else
        -- json
        local buffer = rapidjson.encode(request)
        return buffer
    end
end
function rpc:encodeResponse(msgID, response)
    local info = self.m_msgMap[msgID]
    if info == nil then
        log_error("msgID is not registered", msgID)
        return
    end
    return rpc:encodeResponseByInfo(info, response)
end
function rpc:encodeResponseByInfo(info, response)
    local msgSource = info.msgSource
    if msgSource == "pb" then
        local buffer,err = eproto.encode(info.responseName, response)
        if not buffer then
            log_error("encodeResponseByInfo failed eproto.encode", info.msgID, "code", err, info.responseName)
            return
        end
        return buffer
    elseif msgSource == "mp" then
        local buffer = eproto.pack(response)
        return buffer
    else
        -- json
        local buffer = rapidjson.encode(response)
        return buffer
    end
end
function rpc:decodeRpc(isResponse, msgID, buffer, info)
    if info == nil then
        info = self.m_msgMap[msgID]
    end
    if info == nil then
        log_error("decodeRequest failed info == nil", msgID)
        return
    end
    -- 特殊处理
    if buffer == nil or #buffer == 0 then
        log_debug("buffer for rpc is empty", isResponse, msgID)
        return {}
    end
    local msgSource = info.msgSource
    if msgSource == "pb" then
        local pbName
        if isResponse then
            pbName = info.responseName
        else
            pbName = info.requestName
        end
        local request,err = eproto.decode(pbName, buffer)
        if not request then
            local arr = {}
            for k=1,#buffer do
                local c = string.sub(buffer, k, k)
                table.insert(arr, string.format("0x%x", string.byte(c)))
            end
            log_error("decodeRequest failed eproto.decode", msgID, pbName, err, "#buffer", #buffer, table.concat(arr, " "))
            return
        end
        return request
    elseif msgSource == "mp" then
        local request = eproto.unpack(buffer)
        return request
    else
        local request,err = rapidjson.decode(buffer)
        if not request then
            log_error("rapidjson.decode failed", err, buffer)
        end
        return request
    end
end
function rpc:encodeRpcHeadByContentType(contentType, command, body, rpcReq)
    local info = {
        msg_id = rpcReq.msg_id;
        callback_id = rpcReq.callback_id;
        error_code = (rpcReq.error_code or 0);
        command = command;
        uid = rpcReq.uid;
        body = body;
    }
    local buffer
    if contentType == EprotoType then
        buffer = eproto.encode("rocket.rpc", info)
    elseif contentType == MessagePackType then
        buffer = eproto.pack(info)
    else
        -- 默认使用JSON
        buffer = rapidjson.encode(info)
    end
    return buffer
end
function rpc:encodeRpcHead(command, body, rpcReq)
    local info = {
        msg_id = rpcReq.msg_id;
        callback_id = rpcReq.callback_id;
        error_code = (rpcReq.error_code or 0);
        command = command;
        uid = rpcReq.uid;
        body = body;
    }
    local buffer = eproto.encode("rocket.rpc", info)
    return buffer
end
function rpc:decodeRpcHead(buffer)
    local info = eproto.decode("rocket.rpc", buffer)
    return info
end

return rpc
